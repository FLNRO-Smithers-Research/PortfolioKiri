---
title: "CBSTPortfolio"
author: "Kiri Daust"
date: "01/05/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = './CBSTPortfolio')
require(tcltk)
require(dplyr)
require(ggplot2)
require(MASS)
require(magrittr)
require(foreach)
require(reshape2)
require(doParallel)
require(reticulate)
require(Rcpp)
library(gridExtra)
library(data.table)
library(scales)
library(tidyr)

path_to_python <- "C:/Users/whmacken/anaconda3"
use_python(path_to_python)

sourceCpp("CppFunctions/SimGrowth.cpp")
reticulate::source_python("PythonFns/PortfolioOptimisation.py")
```

### Set parameters for gs2gw function

```{r gs2gw}
setGW <- function(k = 0.9){
  dat <- data.frame(x = c(0.85,0.87,k,0.99,1), y = c(0,0,0.01,0.95,1))
  cont <- nls.control(maxiter = 500, minFactor = 1/5000, warnOnly = TRUE)
  fit <- nls(y ~ a*exp(x*b), data = dat, start = list(a = 5e-25, b = 55.9), control = cont)
  return(coef(fit))
}
params <- setGW(0.96)
```

### Read in data

```{r input}
modelYears <- 60
modPeriod <- c(2025,2055)
individualGraphs <- "No" ##print graphs for each model?

###read in CBST data
Trees <- c("Bl","Cw","Fdi","Hw","Lw","Pli","Py","Sx") ##set species to use in portfolio
dir <- "CBSTNoMigration"
files <- list.files(dir)
allSppDat <- foreach(Spp = Trees, .combine = rbind) %do% {
  fName <- paste(dir, files[grep(paste(Spp,"_",sep = ""),files)], sep = "/")
  temp <- fread(fName, data.table = F)
  temp$Spp <- Spp
  temp
}
colnames(allSppDat) <- c("Site","Seed","Height", "Spp")

##import BGC prediction by model
SSPredAll <- read.csv(file.choose())##import BGC predictions from CCISS script
BGC <- "IDFdk3" ###select BGC
SSPredAll <- SSPredAll[SSPredAll$BGC == BGC,]
SSPredAll <- SSPredAll[grep("Ele",SSPredAll$SiteNo),]
SSPredAll <- SSPredAll[SSPredAll$FuturePeriod %in% modPeriod,]
```

### Setup parallelisation
- Have to load python/c functions on each worker

```{r parallel}
worker.init <- function(){
    Rcpp::sourceCpp("../CppFunctions/SimGrowth.cpp")
    reticulate::source_python("../PythonFns/PortfolioOptimisation.py")
  }
  
require(doParallel)
cl <- makePSOCKcluster(detectCores()-2)
clusterCall(cl, worker.init)
registerDoParallel(cl)
```

### Run CBST Portfolio

```{r runPortfolio}
Spp = "Fdi"
SuitTable <- allSppDat[allSppDat$Spp == Spp,]
SuitTable <- SuitTable[,-4]
SSPredAll$SiteNo <- as.character(SSPredAll$SiteNo)
SSPredAll <- SSPredAll[order(SSPredAll$SiteNo,SSPredAll$GCM),]
SiteList <- unique(SSPredAll$SiteNo)

simulateGrowth <- function(x, nYears = modYears){ ###remove any not suitable in any time period
  if(any(x < 0) || max(x) < 0.5){return(NULL)}
  else{
    s <- spline(c(2000,modPeriod), x, n = nYears+1)
    growthRate <- s[["y"]]
    pDead <- 1 - s[["y"]]
    pDead <- rescale(pDead, to = c(0.01,0.1), from = c(0,1)) %>% multiply_by(100)
    
    annualDat <- data.frame("Year" = seq(2000,2000+nYears,1), "Growth" = growthRate, "MeanDead" = pDead, "NoMort" = rep(25, nYears+1)) ##create working data
    
    Returns <- simGrowthCBST(DF = annualDat)
    
    return(Returns)
  }
  
}

allSites <- foreach(SNum = SiteList, .combine = rbind, .packages = c("reshape2","Rcpp","magrittr","scales","reticulate"), .noexport = 
                        c("gs2gw", "simGrowthCBST","simGrowthCpp")) %dopar% {
    
    reticulate::source_python("../PythonFns/PortfolioOptimisation.py")
    
    SSPred <- SSPredAll[SSPredAll$SiteNo == SNum,]
    currBGC <- as.character(SSPred$BGC[1])
    
    SSPred <- merge(SSPred,SuitTable, by.x = "BGC.pred", by.y = "Site", all.x = TRUE)
    
    modList <- as.character(unique(SSPred$GCM))
    output <- data.frame(Return = numeric(), variable = character(), value = numeric(), Model = character())
    temp <- unique(SSPred$Seed)
    #modList <- modList[grep("rcp85",modList)] ##select just rcp8.5 models
    grList <- list()
    
    for(mod in modList){
      cat("Model",mod,"\n")
      SSPredMod <- SSPred[SSPred$GCM == mod,]
      if(any(is.na(SSPredMod$Seed))){next}
      SeedList <- unique(SSPredMod$Seed)
      returns <- data.frame(Year = seq(2000,2000+modelYears,1))
      modData <- data.frame(Seed = character(), Year = numeric(), Returns = numeric())
      
      for(seed in SeedList){
        SSPredSd <- SSPredMod[SSPredMod$Seed == seed,]
        SSPredSd <- SSPredSd[order(SSPredSd$GCM,SSPredSd$FuturePeriod),]
        SS.sum <- SSPredSd[,c("FuturePeriod","Height")]
        curr <- data.frame(FuturePeriod = 2000, 
                           Height = SuitTable$Height[SuitTable$Site == BGC & SuitTable$Seed == as.character(seed)])
        SS.sum <- rbind(curr, SS.sum)
        SS.sum$Height <- gs2gw(SS.sum$Height, as.numeric(params[1]), as.numeric(params[2]))
        SS.sum <- SS.sum[complete.cases(SS.sum),]
        
        Returns <- simulateGrowth(SS.sum$Height, nYears = modelYears)
        if(is.null(Returns)){next}
        tmpR <- c(0,Returns)
        assets <- Returns - tmpR[-length(tmpR)]
        dat <- data.frame(Seed = rep(seed,modelYears+1), Year = 1:(modelYears+1), Returns = assets)
        modData <- rbind(modData, dat)
      }
      modData <- dcast(modData, Year ~ Seed, value.var = "Returns")
      returns <- modData
      rownames(returns) <- returns[,1]
      returns <- returns[,-1]
      sigma2 <- as.data.frame(cor(returns)) ###to create cov mat from returns
      ##target <- set_target(returns, sigma2) ###find range of efficient frontier
      target <- seq(0.3,0.9,by = 0.02)
      
      ef <- ef_weights_cbst(returns, sigma2, target, 0, 1, 0.15) ## call python function
      ef_w <- as.data.frame(ef[[1]])
      ef_w$Sd <- c(ef[[2]])
      
      dat <- ef_w
      dat$Return <- target
      
      #####graph individual model############
      if(individualGraphs == "Yes"){
        datRet <- melt(dat, id.vars = "Sd")
        datRet <- datRet[datRet$variable != "Return",]
        datRet$Sd <- round(datRet$Sd, digits = 2)
        datRet <- dcast(datRet, Sd ~ variable, fun.aggregate = mean) %>% melt(id.vars = "Sd")
        for(R in unique(datRet$Sd)){###scale each out of 1
          datRet$value[datRet$Sd == R] <- datRet$value[datRet$Sd == R]/sum(datRet$value[datRet$Sd == R])
        }
        grList[[mod]] <- (ggplot(datRet)+
          geom_area(aes(x = Sd, y = value, fill = variable),size = 0.00001, col = "black", stat = "identity")+
          scale_x_reverse()+
          ggtitle(mod))
      }
      
      ########################################
      
      dat$Sd <- round(dat$Sd, digits = 2)
      dat <- melt(dat, id.vars = "Return")
      dat$Model <- mod
      output <- rbind(output, dat)
    }
    output$SiteNo <- SNum
    output
  } 
```

### Graph results

```{r graph}
dat <- allSites[complete.cases(allSites),]
dat <- dat[!is.nan(dat$value),]
dat <- dcast(dat, Return ~ variable, fun.aggregate = function(x){sum(x)/(30*length(SiteList))})
dat <- dat[,colMeans(dat, na.rm = T) > 0.01]
dat$Sd <- round(dat$Sd,digits = 1)

dat <- melt(dat, id.vars = "Sd") %>% dcast(Sd ~ variable, fun.aggregate = mean)
dat <- melt(dat, id.vars = "Sd")
dat <- dat[dat$variable != "Return",]
for(R in unique(dat$Sd)){###scale each out of 1
  dat$value[dat$Sd == R] <- dat$value[dat$Sd == R]/sum(dat$value[dat$Sd == R])
}
ggplot(dat)+
  geom_area(aes(x = Sd, y = value, fill = variable),size = 0.00001, col = "black", stat = "identity")+
  scale_x_reverse()+
  ggtitle("CBST by Volatility")

```