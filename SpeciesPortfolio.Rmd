---
title: "Climate Change Optimized Species Portfolio for Reforestation Planning"
author: "Will MacKenzie and Kiri Daust"
date: "17/05/2020"
output:
  html_document: 
    fig_caption: yes
    theme: lumen
    toc: yes
---

This report presents a range of risk-return optimized portfolios of tree species generated using Markowitz Modern Portfolio Theory (MPT). The analysis uses forecast site series level changes to species feasibility from the Climate Change-Informed Species Selection (CCISS) tool, and site index by site series growth information (SIBEC) to calculate the optimal mix of tree species given the modelled uncertainty in future climates up to 2070.
The CCISS model forecasts future BGCs for 30 GCM/carbon scenarios for all locations, and aligns the current site series with future potential site series via edatopic overlap. We use a monte carlo approach to simulate growth of each tree species using site index data and stochastic losses based on predicted suitability. The portfolio analysis uses the modelled growth rate and a species covariance matrix to optimise the efficient frontier.
User inputs to the script are spatial point locations with climate data that will represent BGC-based analysis units (e.g. MHmm1_high and MHmm1_low). Users can also adjust the min and max values for each species and the minimum value to be included in the portfolio. 
This report is generated from Rmarkdown, and sources functions from python and C++.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
require(dplyr)
require(ggplot2)
require(MASS)
require(magrittr)
require(foreach)
require(reshape2)
require(reticulate)
require(Rcpp)
library(gridExtra)
library(data.table)
library(scales)
library(tidyr)
library(magrittr)
library(ggthemes)
library(flextable)
require(rgdal)
require(tmap)
library(sf)
require(tufte)
require(Hmisc)
```



```{r read in  portfolio functions}
##Source functions for growth simulations (C++), Portfolio optimization (Python) and CCISS analysis (R)
sourceCpp("./CppFunctions/SimGrowth.cpp")
source_python("./PythonFns/PortfolioOptimisation.py")
source("CCISS_Fns.R")
```



```{r load species data}
##Load data and run CCISS functions (if necessary)

inputDatName <- "SunshPntsNew_90 GCMsMSY.csv" ##generated in ClimateBC for all variable and all future climate scenarios

##Set drive with cloud data
if(dir.exists("C:/users/whmacken/Sync")){
  cloud_dir <- "C:/users/whmacken/Sync/CCISS_data/"
}else{
  cloud_dir <- "C:/Users/kirid/Sync/CCISS_data/"
}

###Read in data
SuitTable <- fread("InputsGit/Feasibility_v11_21.csv") ##tree spp suitability
SuitTable <- unique(SuitTable)

colnames(SuitTable)[2:4] <- c("SS_NoSpace","Spp","Suitability")
SuitTable <- SuitTable[,c("BGC","SS_NoSpace","Spp","Suitability")]

SIBEC <- fread("InputsGit/PredSI_May2020.csv") ###import SI data (currently from BART)

SIBEC <- SIBEC[,c("SS_NoSpace","Spp","SIPred")] %>% set_colnames(c("SS_NoSpace","TreeSpp","MeanPlotSiteIndex"))

if(file.exists(paste0(cloud_dir,"CCISSPred.Rdata"))){
  load(paste0(cloud_dir,"CCISSPred.Rdata"))
}else{
  ### run CCISS function to predict Site Series
  load(paste0(cloud_dir, "WNAv11_35_VAR_SubZone_ranger.Rdata"))
  Edatope <- fread("./InputsGit/Edatopic_v11_20.csv",data.table = F)
  rawDat <- fread(paste0(cloud_dir,"PortfolioFiles/",inputDatName),data.table = F)
  CCISSPred <- CCISS_Spp(Y1 = rawDat,BGCmodel = BGCmodel,E1 = Edatope)
  save(CCISSPred, file = paste0(cloud_dir,"CCISSPred.Rdata"))
}

SSPredFull <- CCISSPred[[1]]
colnames(SSPredFull)[1] <- "MergedBGC"
SSPredFull <- SSPredFull[grep("01",SSPredFull$SSCurrent),]
SSPredFull$CurrBGC <- gsub("/.*","", SSPredFull$SSCurrent)

#SSPredFull <- fread("InputsGit/SunshineSSPred.csv") ##Import SS predictions from CCISS tool: must have columns MergedBGC, Source, SS_NoSpace, SSprob, SSCurrent, FuturePeriod, SiteNo
SSPredFull <- SSPredFull[,c("MergedBGC", "Source", "SS_NoSpace", "SSprob", "SSCurrent", 
                          "FuturePeriod", "SiteNo","CurrBGC")]

##remove cases where not all timeperiods available
SSPredFull <- as.data.table(SSPredFull)
temp <- SSPredFull[,.(Num = length(unique(FuturePeriod))), by = c("SiteNo","SSCurrent")]
temp <- temp[Num == 3,-c("Num")]
SSPredFull <- SSPredFull[temp,on = c("SiteNo","SSCurrent")]
SSPredFull[,SiteNo := as.numeric(SiteNo)]

analUnits <- fread(paste0(cloud_dir,"PortfolioFiles/AnalysisUnits.csv"))
setkey(SSPredFull, SiteNo)
setkey(analUnits, ID1)
SSPredFull <- SSPredFull[analUnits]

SSPredSave <- SSPredFull
```



```{r location map}

## Create m ap of test locations by analysis unit
locations <- fread("./InputsGit/SunshineCoast_SamplePoints_New.csv") 
locations2 <- locations %>% rename(latitude = "ycoord", longitude = "xcoord", elevation = "elevation_1") %>% dplyr::select (id, BGC_analysis,latitude,longitude)
BGCmap <- st_read(dsn = paste0(cloud_dir, "PortfolioFiles/SunshineCoast.gpkg"), layer = "BGC_Dissolved")

locations2 <- st_as_sf(locations2, coords = c("longitude","latitude"), crs = 4326, agr = "constant") %>%
  st_transform(st_crs(BGCmap))

#tmaptools::palette_explorer() ###tool for choosing colours

tmap_mode("view")
tmap_options(basemaps = "OpenTopoMap")
tBGC <- tm_shape (BGCmap) + tm_polygons("BGC", alpha = .9)+
    tm_shape(locations2) + tm_symbols(size = 0.1, shapes = 21:25, col = "BGC_analysis")+
  tm_layout(legend.outside = TRUE, legend.outside.position = "right", legend.stack = "vertical", title = "Sample locations for portfolio development in the Sunshine Coast District", main.title.size = 1)
  
tBGC

```
  

```{r colours}
##Colour development for species 

cols <- fread("./InputsGit/PortfolioSppColours.csv")
cols <- cols[HexColour != "",]
myPal <- cols$HexColour
names(myPal) <- cols$TreeCode


library(unikn)
#seecol(myPal, hex = T, rgb = F)
```



```{r CCISS predictions}
#Function to clean and summarise SIBEC and CCISS data into MeanSI and MeanSuitability
##function to clean data and summarise 
cleanData <- function(SNum,Trees,timePer){
  SSPred <- SSPredAll[SiteNo == SNum,] ###subset
  
  ##Merge SIBEC data
  SIBEC <- SIBEC[TreeSpp %in% Trees,]
  SSPred <- SSPred[SSPred$FuturePeriod %in% timePer,]
  SSPred <- SSPred[,c(6,3,4)]
  SSPred <- merge(SSPred, SIBEC, by = "SS_NoSpace", all.x = TRUE)
  
  
  ###Add rows for species with missing SI - mostly US units here
  add <- foreach(Year = unique(SSPred$FuturePeriod), .combine = rbind) %do%{
    byYear <- SSPred[SSPred$FuturePeriod == Year,]
    foreach(SS = unique(byYear$SS_NoSpace), .combine = rbind) %do%{
      bySS <- byYear[byYear$SS_NoSpace == SS,]
      missing <- Trees[!Trees %in% bySS$TreeSpp]
      new <- bySS[rep(1,length(missing)),]
      new$TreeSpp <- missing
      new
    }
  }
  if(!is.null(add)){
    if(nrow(add) > 0){
      add$MeanPlotSiteIndex <- 5 ##Set missing SI
      SSPred <- rbind(SSPred, add)
    }
  } 
  
  
  SSPred <- SSPred[!is.na(SSPred$TreeSpp),]
  colnames(SSPred)[4] <- "Spp"
  
  ##Add suitability
  SSPred <- merge(SSPred, SuitTable, by = c("SS_NoSpace","Spp"), all.x = TRUE)
  SSPred$Suitability[is.na(SSPred$Suitability)] <- 5
  
  temp <- SIBEC[SIBEC$SS_NoSpace == selectBGC,]
  if(nrow(temp) == 0){
    return(NULL)
  }
  ###Create current data
  current <- temp %>% 
    merge(SuitTable, by.x = c("TreeSpp","SS_NoSpace"), by.y = c("Spp","SS_NoSpace"), all.x = TRUE) %>%
    unique()
  
  ###check that there aren't errors in the table
  temp <- aggregate(SS_NoSpace ~ TreeSpp, current, FUN = length)
  if(any(temp$SS_NoSpace > 1)){
    stop("There are partial duplicates in the suitablity table. Please fix them. :)")
  }
  
  current <- data.frame(Spp = current$TreeSpp, FuturePeriod = 2000, MeanSI = current$MeanPlotSiteIndex, MeanSuit = current$Suitability)
  
  missing <- Trees[!Trees %in% current$Spp]
  if(length(missing) > 0){
    new <- current[rep(1,length(missing)),]
    new$Spp <- missing
    new$MeanSI <- 10
    new$MeanSuit <- 5
    current <- rbind(current, new)
  }
  
  ##Summarise data- average SI and Suit weighted by SSProb
  SS.sum <- SSPred[,.(MeanSI = sum(MeanPlotSiteIndex*(SSprob/sum(SSprob))),
                      MeanSuit = round(sum(Suitability*(SSprob/sum(SSprob))), digits = 0)),
                   by = .(Spp,FuturePeriod)]
  
  SS.sum <- rbind(SS.sum, current)
  SS.sum <- SS.sum[SS.sum$FuturePeriod %in% timePer,]
  ###not sure what we were doing here?
  SS.sum$MeanSI[SS.sum$MeanSuit == 4] <- 5
  SS.sum$MeanSI[SS.sum$MeanSuit == 5] <- 0
  SS.sum$MeanSuit[SS.sum$MeanSuit == 5] <- 4
  SS.sum <- unique(SS.sum)
  SS.sum <- SS.sum[order(SS.sum$Spp,SS.sum$FuturePeriod),]
  return(SS.sum)
}

combineList <- function(...) {##Combine multiple dataframe in foreach loop
  mapply(FUN = rbind, ..., SIMPLIFY=FALSE)
}

loopCombine <- function(a,b){
  G <- c(a$Graph,b$Graph)
  df <- rbind(a$MaxS,b$MaxS)
  return(list(Graph = G, MaxS = df))
}

```

## Model Parameters
Minimum and maximum portfolio ratios can be set for the entire portfolio or by species. These limits will be accounted for in the portfolio often by rebalancing it to include more of an species with similar environmental responses. For example, capping Hw abundance in the portfolio will commonly lead to an increase in the amount of Cw in the portfolio.

```{r model parameters, out.width=8, results = 'hold'}
### Probabilities attached to each suitability
SuitProb <- data.frame("Suit" = c(1,2,3,4), "ProbDead" = c(0.5,0.5,1,4), 
                       "NoMort" = c(70,60,50,30)) ####ProbDead- out of 100 trees, how many will die each year at each suitability. NoMort- Percent of time no mortality

# ft1 <- flextable(SuitProb) %>% set_caption("Probability parameters for tree death")
# 

##Set minimum weighting for any species to appear in portfolio
minAccept <- 0.05 ##min acceptable weight in porfolio - if lower, will remove and re-optimize

# cat (paste (minAccept, "is the minimum percent of portolio for a species to be used in final portfolio"))

Trees <- unique(SIBEC$TreeSpp)
myColours <- data.table(TreeCode = Trees)
myColours <- cols[myColours, on = "TreeCode"]
myColours <- myColours[!is.na(HexColour),]
pal <- myColours$HexColour
names(pal) <- myColours$TreeCode
colScale <- scale_fill_manual(name = "variable", values = pal)
Trees <- myColours$TreeCode

##set min and max weights for each species
boundDat <- data.table(Spp = Trees)
boundDat[,`:=`(minWt = 0, maxWt = 1)]

##adjust min and max weights (or remove species)
## see below examples
# boundDat[Spp == "Hw",maxWt := 0] ##remove Hw
# boundDat[Spp == "Pl",minWt := 0.1] ## set min weight for Pl to 0.1

##############
ft2 <- flextable(boundDat) %>% set_caption("Min and max percent of portolio weiting for individual species in portfolio")

notUse <- boundDat$Spp[boundDat$maxWt == 0]
if(length(notUse > 0)){
  Trees <- Trees[!Trees %in% notUse]
}
nSpp <- length(Trees)
treeList <- Trees


#ft1
ft2

```

Species with maximum weight < `r minAccept*100`% of final portfolio will be removed.


```{r parallelSetup, results = 'hide'}
##Setup for parallel computing

worker.init <- function(){
    Rcpp::sourceCpp("./CppFunctions/SimGrowth.cpp")
}

require(doParallel)
cl <- makePSOCKcluster(detectCores()-2)
clusterCall(cl, worker.init)
registerDoParallel(cl)
```

Loop through BGCs and Subzones, run portfolio optimisation, output graphics and optimum weights

```{r portfolio_function, message = TRUE}
timePeriods = c(2000,2025,2055)
returnValue = 0.9

Units <- unique(SSPredFull$BGC_analysis)
outAll <- foreach(BGC = Units, .combine = loopCombine,
                  .packages = c("reshape2","Rcpp","magrittr","reticulate",
                                "data.table","foreach","ggplot2","ggthemes","scales"), 
                  .noexport = c("gs2gw", "simGrowthCBST","simGrowthCpp")) %dopar% {
  reticulate::source_python("./PythonFns/PortfolioOptimisation.py") ##comment out this line if running sequentially
  SSPredBGC <- SSPredFull[BGC_analysis == BGC,-("BGC_analysis")]
  SSList <- unique(SSPredBGC$SSCurrent)
  SSout <- foreach(selectBGC = SSList, .combine = loopCombine) %do% {
    cat("########## Processing", selectBGC,"###################\n")
    SSPredAll <- SSPredBGC[SSPredBGC$SSCurrent == selectBGC,]
    
    SiteList <- unique(SSPredAll$SiteNo)
    #SiteList <- rep(SiteList, each = round(15/length(SiteList)))
    SSPredAll <- SSPredAll[SSPredAll$SiteNo %in% SiteList & !is.na(SSPredAll$SSprob),]
    
    SL <- SiteList
    allSitesSpp <- foreach(SNum = SL, .combine = rbind, 
                       .packages = c("foreach","reshape2","dplyr","magrittr","Rcpp"), 
                       .noexport = c("simGrowthCpp")) %do% {
                         
                         #cat("Optimising site",SNum,"...\n")
                         SS.sum <- cleanData(SNum, Trees, timePer = timePeriods)
                         SS.sum$FuturePeriod <- as.numeric(SS.sum$FuturePeriod)
                         if(length(timePeriods) == 1){
                           temp <- SS.sum
                           temp$FuturePeriod <- SS.sum$FuturePeriod[1]+85
                           SS.sum <- rbind(SS.sum, temp)
                         }
                         
                         if(!is.null(SS.sum)){
                           annualDat <- data.frame("Year" = seq(2000,2100,1))
                         
                           output <- data.frame("year" = annualDat$Year)
                           
                           for (k in 1:nSpp){ ##for each tree
                             
                             DatSpp <- SS.sum[SS.sum$Spp == treeList[k],]
                             
                             dat <- data.frame("Period" = rescale(as.numeric(DatSpp$FuturePeriod), 
                                                                  to = c(2000,2085)), 
                                               "SIBEC" = DatSpp$MeanSI, "Suit" = DatSpp$MeanSuit)
                             dat$SIBEC <- dat$SIBEC/50 ##for mean annual increment
                             dat <- merge(dat, SuitProb, by = "Suit")
                             s <- approx(dat$Period, dat$SIBEC, n = 101) ##Smooth SI
                             p <- approx(dat$Period, dat$ProbDead, n = 101) ###Smooth Prob Dead
                             m <- approx(dat$Period, dat$NoMort, n = 101) ##Smooth No Mort
                             
                             ###data frame of annual data
                             annualDat <- data.frame("Year" = seq(2000,2100,1), "Growth" = s[["y"]], 
                                                     "MeanDead" = p[["y"]], "NoMort" = m[["y"]]) ##create working data
                             
                             Returns <- simGrowthCpp(DF = annualDat)
                             tmpR <- c(0,Returns)
                             assets <- Returns - tmpR[-length(tmpR)]
                             temp <- data.frame(Spp = rep(treeList[k],101), 
                                                Year = 1:101, Returns = Returns)
                             output <- cbind(output, assets)
                           } ## for each tree species
                           
                           colnames(output) <- c("Year", treeList)
                           
                           ####Portfolio#######################################
                           returns <- output
                           rownames(returns) <- returns[,1]
                           returns <- returns[,-1]
                           ###only include species with mean return > 1 in portfolio
                           use <- colnames(returns)[colMeans(returns) > 1] ###should probably be higher
                           returns <- returns[,use]
                           sigma2 <- as.data.frame(cor(returns)) ###to create cov mat from returns
                       
                           ef <- ef_weights_v2(returns, sigma2, boundDat,minAccept) 
                           ef_w <- ef[[1]]
                           ef_w$Sd <- ef[[2]]
                           ef_w$Return <- 1:20
                           ef_w$RealRet <- ef[[3]]
                           ef_w$Sharpe <- ef[[4]]
  
                           eff_front2 <- as.data.table(ef_w)
                           eff_front2$SiteNo <- SNum
                           melt(eff_front2, id.vars = c("Return","SiteNo"),variable.name = "Spp")
                         }else{
                           NULL
                         }
                         
                       }
    
    if(!is.null(allSitesSpp)){
      efAll <- allSitesSpp
      efAll <- dcast(efAll,Return ~ Spp, fun.aggregate = function(x){sum(x)/(length(SL))})
      efAll <- efAll[complete.cases(efAll),]
      efAll$RealRet <- efAll$RealRet/max(efAll$RealRet) ##standardise return
      RetCurve <- approx(efAll$RealRet,efAll$Sd,xout = returnValue)
      ret90 <- RetCurve$y
      maxSharpe <- efAll[efAll$Sharpe == max(efAll$Sharpe),-c("Return","Sharpe")]
      maxSPos <- maxSharpe$Sd
      maxSharpe <- t(maxSharpe) %>% as.data.frame() %>% 
        mutate(Spp = rownames(.)) %>% set_colnames(c("value","Spp"))
      ret90Props <- efAll[which.min(abs(efAll$RealRet - returnValue)),-c("Return","Sharpe")]
      ret90Props <- t(ret90Props) %>% as.data.frame() %>% 
        mutate(Spp = rownames(.)) %>% set_colnames(c("value","Spp"))
      maxSharpe$SSCurrent <- selectBGC
      maxSharpe$Unit <- BGC
      maxSharpe$SetRet <- ret90Props$value
      efAll <- efAll[,-c("Return","Sharpe")]
      efAll <- melt(efAll, id.vars = "Sd")
      efAll$variable <- factor(efAll$variable, levels = sort(unique(as.character(efAll$variable))))
    
      
      p1 <- ggplot(efAll[efAll$variable != "RealRet",],aes(x = Sd, y = value,group = variable))+
        geom_area(aes(fill = variable), size = 0.00001, col = "grey50", stat = "identity")+
        colScale +
        geom_vline(xintercept = maxSPos, colour = "blue", linetype = "twodash")+
        geom_vline(xintercept = ret90, colour = "grey27",linetype = "dashed")+
        geom_line(data = efAll[efAll$variable == "RealRet",], 
                  aes(x = Sd, y = value), colour = "black",linetype = "F1", size = .75)+
        scale_x_reverse() +
        xlab("Max Return --> Minimized Risk")+
        ylab("Portfolio Ratio")+
        guides(fill=guide_legend("Species"))+
        ggtitle(paste(BGC , "analysis unit", sep = " "))+
        theme_few()
      
      list(Graph = list(p1), MaxS = maxSharpe)
    }
    
  }
}


```


## Portfolio plots for each analysis unit based on a rotation period to 2070  showing the efficient frontier species ratios across risk/return choices. 


```{r plot_pf, fig.height = 15, fig.width = 12, fig.cap = "Efficient frontiers for future portfolios by analysis unit"}
pdfOutput <- F
if(pdfOutput){
  pdf("PortfolioGraphs.pdf", width = 12, height = 15)
  grid.arrange(grobs = outAll$Graph, ncol = 3)
  dev.off()
}
grid.arrange(grobs = outAll$Graph, ncol = 3)
```


## Portfolio of species at the max Sharpe ratio for each analysis unit.

```{r table}
MSWeights <- dcast(outAll$MaxS,Unit ~ Spp)
MSWeights[MSWeights < 0.01] <- NA ## minimum percent for species to appear in portfolio
MSWeights <- MSWeights[,c(T,colSums(MSWeights[,-1], na.rm = T) > 0)]
MSWeights[is.na(MSWeights)] <- 0
cols <- c(names(MSWeights)[!names(MSWeights) %in% Trees],names(MSWeights)[names(MSWeights) %in% Trees])
tab <- flextable(as.data.frame(MSWeights), col_keys = cols)
tab <- colformat_num(tab,j = cols[-1],digits = 2)
tab
```

```{r currPort}
timePeriods = 2000

Units <- unique(SSPredFull$BGC_analysis)
outAllCurr <- foreach(BGC = Units, .combine = rbind,
                  .packages = c("reshape2","Rcpp","magrittr","reticulate",
                                "data.table","foreach","ggplot2","ggthemes","scales"), 
                  .noexport = c("gs2gw", "simGrowthCBST","simGrowthCpp")) %dopar% {
  reticulate::source_python("./PythonFns/PortfolioOptimisation.py") ##comment out this line if running sequentially
  SSPredBGC <- SSPredFull[BGC_analysis == BGC,-("BGC_analysis")]
  SSList <- unique(SSPredBGC$SSCurrent)
  SSout <- foreach(selectBGC = SSList, .combine = loopCombine) %do% {
    cat("########## Processing", selectBGC,"###################\n")
    SSPredAll <- SSPredBGC[SSPredBGC$SSCurrent == selectBGC,]
    
    SiteList <- unique(SSPredAll$SiteNo)
    #SiteList <- rep(SiteList, each = round(15/length(SiteList)))
    SSPredAll <- SSPredAll[SSPredAll$SiteNo %in% SiteList & !is.na(SSPredAll$SSprob),]
    
    SL <- SiteList
    allSitesSpp <- foreach(SNum = SL, .combine = rbind, 
                       .packages = c("foreach","reshape2","dplyr","magrittr","Rcpp"), 
                       .noexport = c("simGrowthCpp")) %do% {
                         
                         #cat("Optimising site",SNum,"...\n")
                         SS.sum <- cleanData(SNum, Trees, timePer = timePeriods)
                         SS.sum$FuturePeriod <- as.numeric(SS.sum$FuturePeriod)
                         if(length(timePeriods) == 1){
                           temp <- SS.sum
                           temp$FuturePeriod <- SS.sum$FuturePeriod[1]+85
                           SS.sum <- rbind(SS.sum, temp)
                         }
                         
                         if(!is.null(SS.sum)){
                           annualDat <- data.frame("Year" = seq(2000,2100,1))
                         
                           output <- data.frame("year" = annualDat$Year)
                           
                           for (k in 1:nSpp){ ##for each tree
                             
                             DatSpp <- SS.sum[SS.sum$Spp == treeList[k],]
                             
                             dat <- data.frame("Period" = rescale(as.numeric(DatSpp$FuturePeriod), 
                                                                  to = c(2000,2085)), 
                                               "SIBEC" = DatSpp$MeanSI, "Suit" = DatSpp$MeanSuit)
                             dat$SIBEC <- dat$SIBEC/50 ##for mean annual increment
                             dat <- merge(dat, SuitProb, by = "Suit")
                             s <- approx(dat$Period, dat$SIBEC, n = 101) ##Smooth SI
                             p <- approx(dat$Period, dat$ProbDead, n = 101) ###Smooth Prob Dead
                             m <- approx(dat$Period, dat$NoMort, n = 101) ##Smooth No Mort
                             
                             ###data frame of annual data
                             annualDat <- data.frame("Year" = seq(2000,2100,1), "Growth" = s[["y"]], 
                                                     "MeanDead" = p[["y"]], "NoMort" = m[["y"]]) ##create working data
                             
                             Returns <- simGrowthCpp(DF = annualDat)
                             tmpR <- c(0,Returns)
                             assets <- Returns - tmpR[-length(tmpR)]
                             temp <- data.frame(Spp = rep(treeList[k],101), 
                                                Year = 1:101, Returns = Returns)
                             output <- cbind(output, assets)
                           } ## for each tree species
                           
                           colnames(output) <- c("Year", treeList)
                           
                           ####Portfolio#######################################
                           returns <- output
                           rownames(returns) <- returns[,1]
                           returns <- returns[,-1]
                           ###only include species with mean return > 1 in portfolio
                           use <- colnames(returns)[colMeans(returns) > 1] ###should probably be higher
                           returns <- returns[,use]
                           sigma2 <- as.data.frame(cor(returns)) ###to create cov mat from returns
                       
                           ef <- ef_weights_v2(returns, sigma2, boundDat,minAccept) 
                           ef_w <- ef[[1]]
                           ef_w$Sd <- ef[[2]]
                           ef_w$Return <- 1:20
                           ef_w$RealRet <- ef[[3]]
                           ef_w$Sharpe <- ef[[4]]
  
                           eff_front2 <- as.data.table(ef_w)
                           eff_front2$SiteNo <- SNum
                           melt(eff_front2, id.vars = c("Return","SiteNo"),variable.name = "Spp")
                         }else{
                           NULL
                         }
                         
                       }
    
    if(!is.null(allSitesSpp)){
      efAll <- allSitesSpp
      efAll <- dcast(efAll,Return ~ Spp, fun.aggregate = function(x){sum(x)/(length(SL))})
      efAll <- efAll[complete.cases(efAll),]
      efAll$RealRet <- efAll$RealRet/max(efAll$RealRet) ##standardise return
      maxSharpe <- efAll[efAll$Sharpe == max(efAll$Sharpe),-c("Return","Sharpe")]
      maxSPos <- maxSharpe$Sd
      maxSharpe <- t(maxSharpe) %>% as.data.frame() %>% 
        mutate(Spp = rownames(.)) %>% set_colnames(c("value","Spp"))
      maxSharpe$SSCurrent <- selectBGC
      maxSharpe$Unit <- BGC

      maxSharpe
    }
    
  }
}
```

## Comparison of max sharpe ratio portfolios and 90% return portfolios for current and future climate

```{r stacked_bar, fig.width = 8.5, fig.height = 9, fig.cap = "Portfolio weighting for current climate (Max Sharpe) and future climate (Max Sharpe and 90% return)"}
curr <- as.data.table(outAllCurr)
fut <- as.data.table(outAll$MaxS)
colnames(curr)[1] <- "CurrentMS"
colnames(fut)[c(1,5)] <- c("FutureMS","Future90%")

dat <- curr[fut, on = c("Unit","Spp")]
dat <- dat[,.(Unit,Spp,CurrentMS,FutureMS,`Future90%`)]
dat <- melt(dat, id.vars = c("Unit","Spp"))
dat <- dat[!Spp %in% c("Sd","RealRet"),]

ggplot(dat, aes(x = variable, y = value, group = Spp, fill = Spp))+
  geom_bar(stat = "identity")+
  colScale+
  facet_wrap(.~Unit)+
  labs(x = "Portfolio Type", y = "Portfolio Ratio")+
  guides(fill=guide_legend("Species"))+
  theme_few()+
  theme(axis.text.x = element_text(angle = 90))
```

## Predicted BGC subzone/variants for each future time period from 30 climate models

Ratio of predicted BGC units for each BGC analysis unit (multiple locations) from CCISS function.

```{r BGC_plot, fig.width=10, fig.height=6, fig.cap = "Ratio of predicted BGCs in each analysis unit"}
BGCPred <- as.data.table(CCISSPred[[2]])
setkey(BGCPred, SiteNo)
BGCPred <- BGCPred[analUnits]
BGCPred <- BGCPred[,.(Num = sum(Pred.len)), keyby = .(FuturePeriod,BGC_analysis,BGC.pred)]
totNum <- BGCPred[,.(Total = sum(Num)), keyby = .(FuturePeriod,BGC_analysis)]
BGCPred <- totNum[BGCPred]
BGCPred[,Prop := Num/Total]

period <- 2055
BGCPred <- BGCPred[FuturePeriod == period & Prop > 0.05,]
BGCPred[,Prop := Num/sum(Num), by = BGC_analysis]

ggplot(BGCPred, aes(x = BGC_analysis,y = Prop, fill = BGC.pred))+
  geom_bar(stat = 'identity')+
  theme_few()+
  theme(axis.text.x = element_text(angle = 90))
```

## Estimated site index for each portfolio species of analysis units in each future period

```{r SI_check, fig.width = 10, fig.height = 14, fig.cap = "Mean and 95% CI for SI within Spp and Period, weighted by SSprob"}

weighted_ci <- function(x, weights, conf.level = 0.95) { ## main idea from Hack-R on Stack Overflow
    nx <- length(x)
    df <- nx - 1
    vx <- wtd.var(x, weights, normwt = F)
    mx <- weighted.mean(x, weights)
    stderr <- sqrt(vx/nx)
    tstat <- mx/stderr
    alpha <- 1 - conf.level
    cint <- qt(1 - alpha/2, df)
    cint <- tstat + c(-cint, cint)
    cint * stderr
}

gr <- foreach(unit = unique(SSPredFull$BGC_analysis),.combine = c) %do% {
  sub <- SSPredFull[BGC_analysis == unit,]
  sub <- SIBEC[sub, on = "SS_NoSpace"]
  sub[,SI := weighted.mean(MeanPlotSiteIndex,SSprob), by = .(FuturePeriod, TreeSpp)]
  sub[,CI_min := weighted_ci(MeanPlotSiteIndex,SSprob)[1], by = .(FuturePeriod, TreeSpp)]
  sub[,CI_max := weighted_ci(MeanPlotSiteIndex,SSprob)[2], by = .(FuturePeriod, TreeSpp)]
  
  p1 <- ggplot(sub, aes(x = TreeSpp, y = SI, fill = FuturePeriod))+
    geom_bar(stat = "identity", position = "dodge")+
    geom_errorbar(aes(ymin = CI_min, ymax = CI_max), width = 0.2, position = position_dodge(width = 0.9))+
    theme_few()+
    geom_hline(yintercept = c(10,20), colour = "black")+
    ggtitle(unit)
  list(p1)
}

grid.arrange(grobs = gr, ncol = 2)
```