  ---
title: "SpeciesPortfolio"
author: "Kiri Daust"
date: "17/05/2020"
output:
  html_document: default
  pdf_document: default
---

This script uses an adaptation of Markowitz Modern Portfolio Theory (MPT) analysis to calculate the optimal mix of tree species for a given set of locations and specified site series. 
The model uses the CCISS model to forecast future BGC for 30 GCM/carbon scenarios for all locations and aligns the current site series with future potential site series via edatopic overlap. A MPT portfolio is constructed for each future climate using data on tree species suitability, site index by site series information, and covariance of species in all current and potenial future site series. Probabalistic loss rates are modelled based on species suitability. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
require(dplyr)
require(ggplot2)
require(MASS)
require(magrittr)
require(foreach)
require(reshape2)
require(reticulate)
require(Rcpp)
library(gridExtra)
library(data.table)
library(scales)
library(tidyr)
library(magrittr)
library(ggthemes)
library(flextable)
require(rgdal)
require(tmap)
library(sf)
```


```{r read in  portfolio functions}
##Source functions for growth simulations (C++), Portfolio optimization (Python) and CCISS analysis (R)
sourceCpp("./CppFunctions/SimGrowth.cpp")
source_python("./PythonFns/PortfolioOptimisation.py")
source("CCISS_Fns.R")
```


```{r load species data}
##Set drive with cloud data
cloud_dir_will <- "C:/users/whmacken/Sync/CCISS_data/"
cloud_dir_kiri <- "C:/Users/kirid/Sync/CCISS_data/"
###Read in data
SuitTable <- fread("InputsGit/Feasibility_v11_21.csv") ##tree spp suitability
SuitTable <- unique(SuitTable)

colnames(SuitTable)[2:4] <- c("SS_NoSpace","Spp","Suitability")
SuitTable <- SuitTable[,c("BGC","SS_NoSpace","Spp","Suitability")]

SIBEC <- fread("InputsGit/PredSI_May2020.csv") ###import SI data (currently from BART)

SIBEC <- SIBEC[,c("SS_NoSpace","Spp","SIPred")] %>% set_colnames(c("SS_NoSpace","TreeSpp","MeanPlotSiteIndex"))

### run CCISS function to predict Site Series
load(paste0(cloud_dir_kiri, "WNAv11_35_VAR_SubZone_ranger.Rdata"))

Edatope <- fread("./InputsGit/Edatopic_v11_20.csv",data.table = F)
rawDat <- fread(paste0(cloud_dir_kiri,"PortfolioFiles/SunshPts_90 GCMsMSY.csv"),data.table = F)
rawDat$ID2 <- gsub("(.*)[A-Z]$","\\1",rawDat$ID2) ##remove north/south
CCISSPred <- CCISS_Spp(Y1 = rawDat,BGCmodel = BGCmodel,E1 = Edatope)
SSPredFull <- CCISSPred[[1]]
colnames(SSPredFull)[1] <- "MergedBGC"
SSPredFull <- SSPredFull[grep("01",SSPredFull$SSCurrent),]
SSPredFull$CurrBGC <- gsub("/.*","", SSPredFull$SSCurrent)

#SSPredFull <- fread("InputsGit/SunshineSSPred.csv") ##Import SS predictions from CCISS tool: must have columns MergedBGC, Source, SS_NoSpace, SSprob, SSCurrent, FuturePeriod, SiteNo
SSPredFull <- SSPredFull[,c("MergedBGC", "Source", "SS_NoSpace", "SSprob", "SSCurrent", 
                          "FuturePeriod", "SiteNo","CurrBGC")]

##remove cases where not all timeperiods available
SSPredFull <- as.data.table(SSPredFull)
temp <- SSPredFull[,.(Num = length(unique(FuturePeriod))), by = c("SiteNo","SSCurrent")]
temp <- temp[Num == 3,-c("Num")]
SSPredFull <- SSPredFull[temp,on = c("SiteNo","SSCurrent")]

SSPredSave <- SSPredFull
```

Map of test locations by analysis unit
```{r location map}
locations <- fread("./InputsGit/SunshineCoast_SamplePoints_New.csv") 
locations2 <- locations %>% rename(latitude = "ycoord", longitude = "xcoord", elevation = "elevation_1") %>% dplyr::select (id, BGC_analysis,latitude,longitude)
BGCmap <- st_read(dsn = paste0(cloud_dir_kiri, "PortfolioFiles/SunshineCoast.gpkg"), layer = "BGC_Dissolved")

locations2 <- st_as_sf(locations2, coords = c("longitude","latitude"), crs = 4326, agr = "constant") %>%
  st_transform(st_crs(BGCmap))
#identical(proj4string(provmap),proj4string(mnt_georef3))# double check that they match

#tmaptools::palette_explorer() ###tool for choosing colours

tmap_mode("view")
tmap_options(basemaps = "OpenTopoMap")
tBGC <- tm_shape (BGCmap) + tm_polygons("BGC", alpha = .9)+
    tm_shape(locations2) + tm_symbols(size = 0.1, shapes = 21:25, col = "BGC_analysis")+
  tm_layout(legend.outside = TRUE, legend.outside.position = "right", legend.stack = "vertical", title = "Sample locations for portfolio development in the Sunshine Coast District", main.title.size = 1)
  
tBGC

```
  
Ratio of predicted BGC units for each landscape/BGC analysis unit (multiple locations) from CCISS function.

```{r BGC_plot, fig.width=10, fig.height=8}
BGCPred <- as.data.table(CCISSPred[[2]])
BGCPred <- BGCPred[,.(Num = sum(Pred.len)), keyby = .(FuturePeriod,BGC,BGC.pred)]
totNum <- BGCPred[,.(Total = sum(Num)), keyby = .(FuturePeriod,BGC)]
BGCPred <- totNum[BGCPred]
BGCPred[,Prop := Num/Total]

period <- 2025
BGCPred <- BGCPred[FuturePeriod == period & Prop > 0.05,]

gr <- foreach(unit = unique(BGCPred$BGC), .combine = c) %do% {
  temp <- BGCPred[BGC == unit,]
  p1 <- ggplot(temp, aes(x = BGC.pred, y = Prop, fill = BGC.pred))+
  geom_bar(stat = 'identity', position = "dodge")+
    ggtitle(unit)+
    theme_few()+
    theme(axis.text.x = element_blank())
  list(p1)
}

grid.arrange(grobs = gr, ncol = 3)
```

Site Index of portfolio species for each BGC

```{r SI_check, fig.width = 10, fig.height = 12}
gr <- foreach(unit = unique(SSPredFull$SSCurrent),.combine = c) %do% {
  sub <- SSPredFull[SSCurrent == unit,]
  sub <- SIBEC[sub, on = "SS_NoSpace"]
  sub <- sub[,.(SI = weighted.mean(MeanPlotSiteIndex,SSprob)), by = .(FuturePeriod, TreeSpp)]
  
  p1 <- ggplot(sub, aes(x = TreeSpp, y = SI, fill = FuturePeriod))+
    geom_bar(stat = "identity", position = "dodge")+
    theme_few()+
    ggtitle(unit)
  list(p1)
}

grid.arrange(grobs = gr, ncol = 2)
```

Colour development...

```{r colours}
cols <- fread("./InputsGit/PortfolioSppColours.csv")
cols <- cols[HexColour != "",]
myPal <- cols$HexColour
names(myPal) <- cols$TreeCode


library(unikn)
seecol(myPal, hex = T, rgb = F)
```


```{r CCISS predictions}
##Function to clean and summarise SIBEC and CCISS data
##function to clean data and summarise 
cleanData <- function(SNum,Trees){
  SSPred <- SSPredAll[SiteNo == SNum,] ###subset
  
  ##Merge SIBEC data
  SIBEC <- SIBEC[TreeSpp %in% Trees,]
  SSPred <- SSPred[,c(6,3,4)]
  SSPred <- merge(SSPred, SIBEC, by = "SS_NoSpace", all.x = TRUE)
  
  
  ###Add rows for species with missing SI - mostly US units here
  add <- foreach(Year = unique(SSPred$FuturePeriod), .combine = rbind) %do%{
    byYear <- SSPred[SSPred$FuturePeriod == Year,]
    foreach(SS = unique(byYear$SS_NoSpace), .combine = rbind) %do%{
      bySS <- byYear[byYear$SS_NoSpace == SS,]
      missing <- Trees[!Trees %in% bySS$TreeSpp]
      new <- bySS[rep(1,length(missing)),]
      new$TreeSpp <- missing
      new
    }
  }
  if(nrow(add) > 0){
    add$MeanPlotSiteIndex <- 5 ##Set missing SI
    SSPred <- rbind(SSPred, add)
  }
  
  
  SSPred <- SSPred[!is.na(SSPred$TreeSpp),]
  colnames(SSPred)[4] <- "Spp"
  
  ##Add suitability
  SSPred <- merge(SSPred, SuitTable, by = c("SS_NoSpace","Spp"), all.x = TRUE)
  SSPred$Suitability[is.na(SSPred$Suitability)] <- 5
  
  temp <- SIBEC[SIBEC$SS_NoSpace == selectBGC,]
  if(nrow(temp) == 0){
    return(NULL)
  }
  ###Create current data
  current <- temp %>% 
    merge(SuitTable, by.x = c("TreeSpp","SS_NoSpace"), by.y = c("Spp","SS_NoSpace"), all.x = TRUE) %>%
    unique()
  
  ###check that there aren't errors in the table
  temp <- aggregate(SS_NoSpace ~ TreeSpp, current, FUN = length)
  if(any(temp$SS_NoSpace > 1)){
    stop("There are partial duplicates in the suitablity table. Please fix them. :)")
  }
  
  current <- data.frame(Spp = current$TreeSpp, FuturePeriod = 2000, MeanSI = current$MeanPlotSiteIndex, MeanSuit = current$Suitability)
  
  missing <- Trees[!Trees %in% current$Spp]
  if(length(missing) > 0){
    new <- current[rep(1,length(missing)),]
    new$Spp <- missing
    new$MeanSI <- 10
    new$MeanSuit <- 5
    current <- rbind(current, new)
  }
  
  ##Summarise data- average SI and Suit weighted by SSProb
  SS.sum <- SSPred[,.(MeanSI = sum(MeanPlotSiteIndex*(SSprob/sum(SSprob))),
                      MeanSuit = round(sum(Suitability*(SSprob/sum(SSprob))), digits = 0)),
                   by = .(Spp,FuturePeriod)]
  
  SS.sum <- rbind(SS.sum, current)
  ###not sure what we were doing here?
  SS.sum$MeanSI[SS.sum$MeanSuit == 4] <- 5
  SS.sum$MeanSI[SS.sum$MeanSuit == 5] <- 0
  SS.sum$MeanSuit[SS.sum$MeanSuit == 5] <- 4
  SS.sum <- unique(SS.sum)
  SS.sum <- SS.sum[order(SS.sum$Spp,SS.sum$FuturePeriod),]
  return(SS.sum)
}

combineList <- function(...) {##Combine multiple dataframe in foreach loop
  mapply(FUN = rbind, ..., SIMPLIFY=FALSE)
}

loopCombine <- function(a,b){
  G <- c(a$Graph,b$Graph)
  df <- rbind(a$MaxS,b$MaxS)
  return(list(Graph = G, MaxS = df))
}

```

Specify model parameters

```{r model parameters}
### Probabilities attached to each suitability
SuitProb <- data.frame("Suit" = c(1,2,3,4), "ProbDead" = c(0.5,0.5,1,4), 
                       "NoMort" = c(70,60,50,30)) ####ProbDead- out of 100 trees, how many will die each year at each suitability. NoMort- Percent of time no mortality

knitr::kable(SuitProb)

Trees <- unique(SIBEC$TreeSpp)
myColours <- data.table(TreeCode = Trees)
myColours <- cols[myColours, on = "TreeCode"]
myColours <- myColours[!is.na(HexColour),]
pal <- myColours$HexColour
names(pal) <- myColours$TreeCode
colScale <- scale_fill_manual(name = "variable", values = pal)
Trees <- myColours$TreeCode


##set min and max weights for each species
boundDat <- data.table(Spp = Trees)
boundDat[,`:=`(minWt = 0, maxWt = 1)]

##adjust min and max weights (or remove species)
## see below examples
boundDat[Spp == "Hw",maxWt := 0] ##remove Hw
boundDat[Spp == "Pl",minWt := 0.1] ## set min weight for Pl to 0.1

##############
knitr::kable(boundDat)

notUse <- boundDat$Spp[boundDat$maxWt == 0]
if(length(notUse > 0)){
  Trees <- Trees[!Trees %in% notUse]
}
nSpp <- length(Trees)
treeList <- Trees

minAccept <- 0.1 ##min acceptable weight in porfolio - if lower, will remove and re-optimize

```

Loop through BGCs and Subzones, output graphics and optimum weights

```{r full portfolio, message = TRUE}
future <- TRUE ## change to false to create portfolio with just current data

BGCs <- unique(SSPredFull$CurrBGC)

outAll <- foreach(BGC = BGCs, .combine = loopCombine) %do% {
  SSPredBGC <- SSPredFull[CurrBGC == BGC,]
  SSList <- unique(SSPredBGC$SSCurrent)
  SSout <- foreach(selectBGC = SSList, .combine = loopCombine) %do% {
    cat("########## Processing", selectBGC,"###################\n")
    SSPredAll <- SSPredFull[SSPredFull$SSCurrent == selectBGC,]
    
    SiteList <- unique(SSPredAll$SiteNo)
    SiteList <- rep(SiteList, each = round(15/length(SiteList)))
    SSPredAll <- SSPredAll[SSPredAll$SiteNo %in% SiteList & !is.na(SSPredAll$SSprob),]
    
    SL <- SiteList
    allSitesSpp <- foreach(SNum = SL, .combine = rbind, 
                       .packages = c("foreach","reshape2","dplyr","magrittr","Rcpp"), 
                       .noexport = c("simGrowthCpp")) %do% {
                         
                         #cat("Optimising site",SNum,"...\n")
                         SS.sum <- cleanData(SNum, Trees)
                         
                         if(!future){
                           tempSI <- SS.sum$MeanSI[SS.sum$FuturePeriod == 2000]
                           tempSuit <- SS.sum$MeanSuit[SS.sum$FuturePeriod == 2000]
                           SS.sum$MeanSI <- rep(tempSI, each = 4)
                           SS.sum$MeanSuit <- rep(tempSuit, each = 4)
                         }
                         
                         if(!is.null(SS.sum)){
                           annualDat <- data.frame("Year" = seq(2000,2100,1))
                         
                           output <- data.frame("year" = annualDat$Year)
                           
                           for (k in 1:nSpp){ ##for each tree
                             
                             DatSpp <- SS.sum[SS.sum$Spp == treeList[k],]
                             
                             dat <- data.frame("Period" = c(2000,2025,2055,2085), "SIBEC" = DatSpp$MeanSI, "Suit" = DatSpp$MeanSuit)
                             dat$SIBEC <- dat$SIBEC/50 ##for mean annual increment
                             dat <- merge(dat, SuitProb, by = "Suit")
                             s <- approx(dat$Period, dat$SIBEC, n = 101) ##Smooth SI
                             p <- approx(dat$Period, dat$ProbDead, n = 101) ###Smooth Prob Dead
                             m <- approx(dat$Period, dat$NoMort, n = 101) ##Smooth No Mort
                             
                             ###data frame of annual data
                             annualDat <- data.frame("Year" = seq(2000,2100,1), "Growth" = s[["y"]], 
                                                     "MeanDead" = p[["y"]], "NoMort" = m[["y"]]) ##create working data
                             
                             Returns <- simGrowthCpp(DF = annualDat)
                             tmpR <- c(0,Returns)
                             assets <- Returns - tmpR[-length(tmpR)]
                             temp <- data.frame(Spp = rep(treeList[k],101), Year = 1:101, Returns = Returns)
                             output <- cbind(output, assets)
                           } ## for each tree species
                           
                           colnames(output) <- c("Year", treeList)
                           
                           ####Portfolio#######################################
                           returns <- output
                           rownames(returns) <- returns[,1]
                           returns <- returns[,-1]
                           ###only include species with mean return > 1 in portfolio
                           use <- colnames(returns)[colMeans(returns) > 1] ###should probably be higher
                           returns <- returns[,use]
                           sigma2 <- as.data.frame(cor(returns)) ###to create cov mat from returns
                       
                           ef <- ef_weights_v2(returns, sigma2, boundDat,minAccept) 
                           ef_w <- ef[[1]]
                           ef_w$Sd <- ef[[2]]
                           ef_w$Return <- 1:20
                           ef_w$RealRet <- ef[[3]]
                           ef_w$Sharpe <- ef[[4]]
  
                           eff_front2 <- as.data.table(ef_w)
                           eff_front2$SiteNo <- SNum
                           melt(eff_front2, id.vars = c("Return","SiteNo"),variable.name = "Spp")
                         }else{
                           NULL
                         }
                         
                       }
    
    if(!is.null(allSitesSpp)){
      efAll <- allSitesSpp
      efAll <- dcast(efAll,Return ~ Spp, fun.aggregate = function(x){sum(x)/(length(SL))})
      efAll <- efAll[complete.cases(efAll),]
      efAll$RealRet <- efAll$RealRet/max(efAll$RealRet) ##standardise return
      maxSharpe <- efAll[efAll$Sharpe == max(efAll$Sharpe),-c("Return","Sharpe")]
      maxSPos <- maxSharpe$Sd
      maxSharpe <- t(maxSharpe) %>% as.data.frame() %>% mutate(Spp = rownames(.)) %>% set_colnames(c("value","Spp"))
      maxSharpe$SSCurrent <- selectBGC
      efAll <- efAll[,-c("Return","Sharpe")]
      efAll <- melt(efAll, id.vars = "Sd")
    
      
      p1 <- ggplot(efAll[efAll$variable != "RealRet",])+
        geom_area(aes(x = Sd, y = value, fill = variable),size = 0.00001, col = "black", stat = "identity")+
        colScale +
        geom_vline(xintercept = maxSPos)+
        geom_line(data = efAll[efAll$variable == "RealRet",], aes(x = Sd, y = value))+
        scale_x_reverse() +
        xlab("Volatility")+
        ggtitle(selectBGC)+
        theme_few()
      
      list(Graph = list(p1), MaxS = maxSharpe)
    }
    
  }
  # pdf(file = paste0(BGC,"_Portfolios.pdf"), width = 6, height = 5)
  # grid.arrange(grobs = SSout$Graph, ncol = 1)
  # dev.off()
}


```

Plot portfolios

```{r plot_pf, fig.height = 10, fig.width = 12}
grid.arrange(grobs = outAll$Graph, ncol = 3)
```


### Formatted table

```{r table}
MSWeights <- dcast(outAll$MaxS,SSCurrent ~ Spp)
MSWeights[MSWeights < 0.05] <- NA
MSWeights <- MSWeights[,c(T,colSums(MSWeights[,-1], na.rm = T) > 0)]
MSWeights[is.na(MSWeights)] <- 0
cols <- c(names(MSWeights)[!names(MSWeights) %in% Trees],names(MSWeights)[names(MSWeights) %in% Trees])
tab <- flextable(MSWeights, col_keys = cols)
tab <- colformat_num(tab,j = cols[-1],digits = 2)
tab
```

Run optimisation (note this may take a bit)

```{r run portfolio}
# SL <- SiteList
# allSitesSpp <- foreach(SNum = SL, .combine = rbind, 
#                        .packages = c("foreach","reshape2","dplyr","magrittr","Rcpp"), 
#                        .noexport = c("simGrowthCpp")) %do% {
#                          cat("Optimising site",SNum,"...\n")
#                          SS.sum <- cleanData(SNum, Trees)
#                          
#                          cols <- rainbow(length(treeList))
#                          annualDat <- data.frame("Year" = seq(2000,2100,1))
#                          
#                          #plot(0,0, type = "n", xlim = c(1,100), ylim = c(0,3000), xlab = "Year", ylab = "Volume")###plot
#                          
#                          eff_front <- foreach(w = 1, .combine = combineList) %do% { ##number of iterations
#                            output <- data.frame("year" = annualDat$Year)
#                            # growthSim <- data.frame(Spp = character(), Year = numeric(), Returns = numeric())
#                            
#                            for (k in 1:nSpp){ ##for each tree
#                              
#                              DatSpp <- SS.sum[SS.sum$Spp == treeList[k],]
#                              
#                              dat <- data.frame("Period" = c(2000,2025,2055,2085), "SIBEC" = DatSpp$MeanSI, "Suit" = DatSpp$MeanSuit)
#                              dat$SIBEC <- dat$SIBEC/50 ##for mean annual increment
#                              dat <- merge(dat, SuitProb, by = "Suit")
#                              s <- approx(dat$Period, dat$SIBEC, n = 101) ##Smooth SI
#                              p <- approx(dat$Period, dat$ProbDead, n = 101) ###Smooth Prob Dead
#                              m <- approx(dat$Period, dat$NoMort, n = 101) ##Smooth No Mort
#                              
#                              ###data frame of annual data
#                              annualDat <- data.frame("Year" = seq(2000,2100,1), "Growth" = s[["y"]], "MeanDead" = p[["y"]], "NoMort" = m[["y"]]) ##create working data
#                              
#                              Returns <- simGrowthCpp(DF = annualDat)
#                              #lines(Returns, type = 'l', col = cols[k])##plot
#                              tmpR <- c(0,Returns)
#                              assets <- Returns - tmpR[-length(tmpR)] 
#                              temp <- data.frame(Spp = rep(treeList[k],101), Year = 1:101, Returns = Returns)
#                              output <- cbind(output, assets)
#                            } ## for each tree species
#                            
#                            #legend("topleft", treeList, col = cols, pch = 15)
#                            
#                            colnames(output) <- c("Year", treeList)
#                            
#                            ####Portfolio#######################################
#                            returns <- output
#                            rownames(returns) <- returns[,1]
#                            returns <- returns[,-1]
#                            ###only include species with mean return > 1 in portfolio
#                            use <- colnames(returns)[colMeans(returns) > 1] ###should probably be higher
#                            returns <- returns[,use]
#                            sigma2 <- as.data.frame(cor(returns)) ###to create cov mat from returns
#                        
#                            ef <- ef_weights_v2(returns, sigma2, minWt,maxWt,minAccept) 
#                            ef_w <- ef[[1]]
#                            ef_w$Sd <- ef[[2]]
#                            ef_w$Return <- 1:20
#                            ef_w$It <- w
#                            
#                     
#                            list(frontier = ef_w)
#                          }
#                          
#                          eff_front2 <- as.data.table(eff_front[['frontier']])
#                          eff_front2$SiteNo <- SNum
#                          melt(eff_front2, id.vars = c("Return","It","SiteNo"),variable.name = "Spp")
#                        }
```

Plot by volatility...

```{r plot portfolio curves}
require(ggthemes)

# efAll <- allSitesSpp
# efAll <- efAll[,-c("It")]
# efAll <- dcast(efAll,Return ~ Spp, fun.aggregate = function(x){sum(x)/(length(SL))})
# efAll <- efAll[complete.cases(efAll),]
# efAll$Return <- efAll$Return/max(efAll$Return) ##standardise return
# 
# efAll <- melt(efAll, id.vars = "Sd")
# 
# myColours <- c("brown","red","pink", "orange","yellow","green","blue","magenta","darkgoldenrod")
# names(myColours) <- levels(factor(Trees))
# colScale <- scale_fill_manual(name = "variable", values = myColours)
# 
# ggplot(efAll[efAll$variable != "Return",])+
#   geom_area(aes(x = Sd, y = value, fill = variable),size = 0.00001, col = "black", stat = "identity")+
#   colScale +
#   geom_line(data = efAll[efAll$variable == "Return",], aes(x = Sd, y = value))+
#   scale_x_reverse() +
#   xlab("Volatility")+
#   ggtitle(selectBGC)+
#   theme_few()
#   #scale_colour_few()

```
