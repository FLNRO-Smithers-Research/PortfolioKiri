---
title: "CBST Portfolio Examples"
author: "Kiri Daust"
date: "May 3, 2019"
output:
  pdf_document: default
  html_document:
    df_print: paged
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(tinytex.verbose = TRUE)
setwd("C:/Users/Kiri Daust/Desktop/PortfolioKiri/CBSTPortfolio")
library(ggplot2)
library(gridExtra)
library(scales)
library(tseries)
library(PortfolioAnalytics)
```

## Brief Description

This document contains a brief description and some examples of using Markowitz Portfolio Optimization to select the best seed to plant given predicted climate change. The general process is outlined below:  

1. Import genetic suitability information and BGC prediction from CCISS tool
2. For each potential seed location within each of the 30 models within each site, do:
    + Create future data by matching each predicted BGC to the corresponding set of genetic suitability
    + Calculate possible max growth each year as $growth = (HTpred - 0.9)*10$
    + Skip seed location if any growths rates < 0
    + Calculate probability of death as $1 - growth$ and rescale to [0.01,0.1]
    + Simulate growth over 100 years with 100 trees using the gamma distribution for probability of death
3. Skip if fewer than 3 possible seed locations for that model
4. Run portfolio optimization within each model using all possible seed locations, each time with 25 different risk aversion levels
5. Remove locations that are only possible in < 25% of climate models
6. Standardize and scale weights and returns

## Example Growth Prediction
The below plot shows the interpolated genetic compatibility for all possilbe seed locations in one site and one model. Each colour represents a seed from a specific BGC

```{r simulation, echo = FALSE}
SSPredAll <- read.csv("TestPredictCBSTPort.csv")##import BGC predictions from CCISS script

###import genetic matrix
fullMat <- read.csv("Pl genetic suitability matrix - no assisted migration.csv")
rownames(fullMat) <- fullMat$BECvar
fullMat <- fullMat[,-1]

##import genetic list
SuitTable <- read.csv("Pl genetic suitability list - no assisted migration.csv")

########################

SeedList <- unique(SuitTable$Seed)
SiteList <- as.character(SSPredAll$SiteNo[SSPredAll$BGC == "SBSmc2"])
outRaw <- data.frame(Seed = SeedList, Number = 0)

###foreach site
  SNum <- SiteList[5]
  EF.out.all <- data.frame(Seed = "SBSmc2", RA = 2)
  EF.ret.all <- data.frame(RA = 2)
  SSPred <- SSPredAll[SSPredAll$SiteNo == SNum,]
  currBGC <- as.character(SSPred$BGC[1])
  
  SSPred <- merge(SSPred,SuitTable, by.x = "BGC.pred", by.y = "Site", all.x = TRUE)
  modList <- as.character(unique(SSPred$GCM))
  output <- data.frame(Seed = SeedList)
  
  for(mod in modList){
    SSPredMod <- SSPred[SSPred$GCM == mod,]
    returns <- data.frame(Year = seq(2000,2100,1))
    modData <- data.frame(Year = seq(2000,2100,1))
    #####plot
    extrapSave <- data.frame(Year = seq(from = 1, to = 101))
    simSave <- data.frame(Year = seq(from = 1, to = 101))
    
    for(seed in SeedList){
      SSPredSd <- SSPredMod[SSPredMod$Seed == seed,]
      SSPredSd <- SSPredSd[order(SSPredSd$GCM,SSPredSd$FuturePeriod),]
      SS.sum <- SSPredSd[,c("FuturePeriod","HTp_pred")]
      colnames(SS.sum)[2] <- "Growth"
      curr <- data.frame(FuturePeriod = 2000, Growth = SuitTable$HTp_pred[SuitTable$Site == as.character(SSPredMod$BGC[1]) & 
                                                                            SuitTable$Seed == as.character(seed)])
      SS.sum <- rbind(curr, SS.sum)
      SS.sum$Growth <- (SS.sum$Growth - 0.9)*10
      SS.sum <- SS.sum[complete.cases(SS.sum),]
      if(any(SS.sum$Growth < 0)){next}
      outRaw$Number[outRaw$Seed == seed] <- outRaw$Number[outRaw$Seed == seed] + 1##count number of times BGC is used
      
      
      annualDat <- data.frame("Year" = seq(2000,2100,1))
      
      portOutput <- data.frame("Seed" = SeedList)###set up plot and output
      ## s <- approx(SS.sum$FuturePeriod, SS.sum$Growth, n = 101) ##Smooth SI
      s <- spline(SS.sum$FuturePeriod, SS.sum$Growth, n = 101)
      growthRate <- s[["y"]]
      extrapSave <- cbind(extrapSave, growthRate)
      pDead <- 1 - s[["y"]]
      pDead <- rescale(pDead, to = c(0.01,0.1), from = c(0,1))
      
      nTrees <- 100 ##number of tree to start
      Returns <- numeric(length = 101)
      
      ###Simulate Growth
      for (i in 1:101){ ##for each year
        height <- sum(growthRate[1:i]) ##total height
        Returns[i] <- nTrees*height ##volume
        prevTrees <- nTrees
        percentDead <- rgamma(1, shape = 1, scale = pDead[i])###what percent of trees will die based on gamma distribution?
        numDead <- (percentDead/100)*prevTrees###number of dead trees
        nTrees <- prevTrees - numDead ##update number of trees
      } ##for each year
      returns <- cbind(returns, Returns)
      colnames(returns)[length(returns)] <- seed
      
      assets <- vector("numeric", 101)
      assets[1] <- Returns[1]
      
      for (z in 1:100){ ##convert from cumulative volume to change by year
        assets[z+1] <- Returns[z+1] - Returns[z]
      }
      #lines(assets)
      modData <- cbind(modData, assets)
      colnames(modData)[length(modData)] <- seed
      
    }
    if(ncol(modData) < 3){next}else{break}
  } 
  plotMultiple <- function(x, title){
    plot(0,0, type = "n", xlim = c(1,100), ylim = c(0,max(x[,-1])), xlab = "Year", ylab = "Volume/Rate", main = title)
    cols <- rainbow(ncol(x) - 1) 
    for(i in 2:ncol(x)){
      lines(x[,i], col = cols[i-1])
    }
  }
  plotMultiple(extrapSave, title = "Extrapolated Genetic Compatibility")
```
---------------
The next plot shows the cumulative growth in each BGC, with added probability of death

```{r plots, echo = FALSE}
  plotMultiple(returns, title = "Cumulative Modeled Growth")
```
------------------
Finaly, we take the derivative of the cumulative growth to obtain the growth rate (note that currently we're adding little prob of death, so it looks very similar to the original compatibility)

```{r plots2, echo = FALSE}
  plotMultiple(modData, title = "Growth Rate")
  
```
-------------------
The code below shows an example of the portfolio optimisation for a given allowable risk with the current settings and output

```{r optim}
  returns <- modData
    rownames(returns) <- paste(returns$Year,"-01-01", sep = "")
    returns <- returns[,-1]
    returnsTS <- as.xts(returns)
    
    init.portfolio <- portfolio.spec(assets = colnames(returnsTS))
    nSpp <- length(colnames(returnsTS))
    init.portfolio <- add.constraint(portfolio = init.portfolio, type = "weight_sum", min_sum = 0.9, max_sum = 1.1) ###weights should add to about 1
    init.portfolio <- add.constraint(portfolio = init.portfolio, type = "box", min = rep(0, nSpp), max = rep(0.95, nSpp)) ##set min and max weight for each species
    
      qu <- add.objective(portfolio=init.portfolio, type="return", name="mean")##add return objective
      qu <- add.objective(portfolio=qu, type="risk", name="var", risk_aversion = 12)##minimize risk using varience
      
      minSD.opt <- optimize.portfolio(R = returnsTS, portfolio = qu, optimize_method = "ROI", trace = TRUE)
      minSD.opt
```

## Example Output
**The examples here are using points within the SBSmc2 subzone in the Bulkley TSA for Lodgepole Pine**  
Efficient frontiers show the optimal weighting of each asset as risk decreases (i.e. the weighting that will give you the most return for an allowable risk). The graphs below show the efficient frontier for six randomly selected individual locations. Each colour represents a seed location, and the black line shows the decrease in max return with decreased risk. 

```{r multiple, out.width="120%", echo=FALSE}
load("BulkelyCBSTExample.RData")
EFall <- allSites$Frontier
EFret <- allSites$Return
sites <- sample(unique(EFall$Site),6,replace = FALSE)
p <- list()
for(i in 1:6){
         p[[i]] <- ggplot(EFall[EFall$Site == sites[i],])+
            geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
            geom_line(data = EFret[EFret$Site == sites[i],], aes(x = Risk, y = MeanRet), size = 2)+
            scale_fill_discrete()+
            labs(x = "Risk (0 = High Risk, 50 = Low Risk)")
}
do.call(grid.arrange,p)

```
---------------------
The below figure is an average efficient frontier over a selection of points in the Bulkley TSA. To make it more readable, only seed locations with a max values > 0.05 are included.

```{r average, echo=FALSE}
EFall <- allSites$Frontier   
EFall <- aggregate(Mean ~ Seed + RA, data = EFall, FUN = mean)
maxW <- aggregate(Mean ~ Seed, data = EFall, FUN = max)
EFall <- EFall[EFall$Seed %in% maxW$Seed[maxW$Mean > 0.15],]
for(R in unique(EFall$RA)){###scale each out of 1
  EFall$Mean[EFall$RA == R] <- EFall$Mean[EFall$RA == R]/sum(EFall$Mean[EFall$RA == R])
}
EFret <- aggregate(MeanRet ~ Risk, data = allSites$Return, FUN = mean)

ggplot(EFall)+
  geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
  geom_line(data = EFret, aes(x = Risk, y = MeanRet), size = 2)+
  scale_fill_discrete()+
  labs(x = "Risk (0 = High Risk, 50 = Low Risk)")

```

