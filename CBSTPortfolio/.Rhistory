modData <- data.frame(Year = seq(2000,2100,1))
##plot(0,0, type = "n", xlim = c(1,100), ylim = c(0,50), xlab = "Year", ylab = "Volume")###plot
for(seed in SeedList){
SSPredSd <- SSPredMod[SSPredMod$Seed == seed,]
SSPredSd <- SSPredSd[order(SSPredSd$GCM,SSPredSd$FuturePeriod),]
SS.sum <- SSPredSd[,c("FuturePeriod","HTp_pred")]
colnames(SS.sum)[2] <- "Growth"
curr <- data.frame(FuturePeriod = 2000, Growth = SuitTable$HTp_pred[SuitTable$Site == as.character(SSPredMod$BGC[1]) &
SuitTable$Seed == as.character(seed)])
SS.sum <- rbind(curr, SS.sum)
SS.sum$Growth <- (SS.sum$Growth - 0.9)*10
SS.sum <- SS.sum[complete.cases(SS.sum),]
if(any(SS.sum$Growth < 0)){next}
outRaw$Number[outRaw$Seed == seed] <- outRaw$Number[outRaw$Seed == seed] + 1##count number of times BGC is used
cols <- rainbow(50)
annualDat <- data.frame("Year" = seq(2000,2100,1))
portOutput <- data.frame("Seed" = SeedList)###set up plot and output
## s <- approx(SS.sum$FuturePeriod, SS.sum$Growth, n = 101) ##Smooth SI
s <- spline(SS.sum$FuturePeriod, SS.sum$Growth, n = 101)
growthRate <- s[["y"]]
#lines(growthRate)
pDead <- 1 - s[["y"]]
pDead <- rescale(pDead, to = c(0.01,0.1), from = c(0,1))
nTrees <- 100 ##number of tree to start
Returns <- numeric(length = 101)
###Simulate Growth
for (i in 1:101){ ##for each year
height <- sum(growthRate[1:i]) ##total height
Returns[i] <- nTrees*height ##volume
prevTrees <- nTrees
percentDead <- rgamma(1, shape = 1, scale = pDead[i])###what percent of trees will die based on gamma distribution?
numDead <- (percentDead/100)*prevTrees###number of dead trees
nTrees <- prevTrees - numDead ##update number of trees
} ##for each year
returns <- cbind(returns, Returns)
colnames(returns)[length(returns)] <- seed
assets <- vector("numeric", 101)
assets[1] <- Returns[1]
for (z in 1:100){ ##convert from cumulative volume to change by year
assets[z+1] <- Returns[z+1] - Returns[z]
}
#lines(assets)
modData <- cbind(modData, assets)
colnames(modData)[length(modData)] <- seed
}
if(ncol(modData) < 3){next}
returns <- modData
rownames(returns) <- paste(returns$Year,"-01-01", sep = "")
returns <- returns[,-1]
#returns <- returns[1:76,]
returnsTS <- as.xts(returns)
init.portfolio <- portfolio.spec(assets = colnames(returnsTS))
nSpp <- length(colnames(returnsTS))
init.portfolio <- add.constraint(portfolio = init.portfolio, type = "weight_sum", min_sum = 0.9, max_sum = 1.1) ###weights should add to about 1
init.portfolio <- add.constraint(portfolio = init.portfolio, type = "box", min = rep(0, nSpp), max = rep(0.95, nSpp)) ##set min and max weight for each species
for(q in seq(from = 2, to = 50, by = 2)){
qu <- add.objective(portfolio=init.portfolio, type="return", name="mean")
qu <- add.objective(portfolio=qu, type="risk", name="var", risk_aversion = q)
minSD.opt <- optimize.portfolio(R = returnsTS, portfolio = qu, optimize_method = "ROI", trace = TRUE)
if(q == 2){
EF.out <-  as.data.frame(minSD.opt[["weights"]])
EF.out$Seed <- rownames(EF.out)
EF.out$RA <- q
EF.ret <- as.data.frame(minSD.opt[["objective_measures"]][["mean"]])
EF.ret$RA <- q
}else{
temp <- as.data.frame(minSD.opt[["weights"]])
temp$Seed <- rownames(temp)
temp$RA <- q
EF.out <- rbind(EF.out, temp)
temp <- as.data.frame(minSD.opt[["objective_measures"]][["mean"]])
temp$RA <- q
EF.ret <- rbind(EF.ret, temp)
}
}
EF.out.all <- merge(EF.out.all, EF.out, by = c("Seed","RA"), all = TRUE)
EF.ret.all <- merge(EF.ret.all, EF.ret, by = "RA", all = TRUE)
}
##if(length(unique(EF.out.all$Seed)) > 2){
EF.out.all$NumNA <- apply(is.na(EF.out.all), 1, FUN = sum)##number of models where it didn't show up
EF.out.all <- EF.out.all[EF.out.all$NumNA < 8,] ##remove seed stock showing up in < 50% of models
EF.out.all[is.na(EF.out.all)] <- 0
EF.out.all$Mean <- apply(EF.out.all[,-c(1,2,length(EF.out.all))],1,mean) ### mean of weights
for(R in EF.out.all$RA){###scale each out of 1
EF.out.all$Mean[EF.out.all$RA == R] <- EF.out.all$Mean[EF.out.all$RA == R]/sum(EF.out.all$Mean[EF.out.all$RA == R])
}
EF.ret.all$Mean <- apply(EF.ret.all[,-1],1,mean, na.rm = TRUE) ###mean of returns
EF.ret.all$Mean <- EF.ret.all$Mean/max(EF.ret.all$Mean) ##scale return out of 1
EF.ret.all <- EF.ret.all[,c(1,length(EF.ret.all))]
colnames(EF.ret.all) <- c("Risk","MeanRet")
EF.sum <- EF.out.all[,c("Seed","RA","Mean")]
print(ggplot(EF.sum)+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EF.ret.all, aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)"))
EF.ret.all$Site <- SNum
outList <- list(Frontier = EF.sum, Return = EF.ret.all)
outList
##}
}
View(allSites)
View(allSites[["Frontier"]])
EFall <- allSites$Frontier
EFall <- aggregate(Mean ~ Seed + RA, data = EFall, FUN = mean)
maxW <- aggregate(Mean ~ Seed, data = EFall, FUN = max)
EFall <- EFall[EFall$Seed %in% maxW$Seed[maxW$Mean > 0.15],]
for(R in unique(EFall$RA)){###scale each out of 1
EFall$Mean[EFall$RA == R] <- EFall$Mean[EFall$RA == R]/sum(EFall$Mean[EFall$RA == R])
}
EFret <- aggregate(MeanRet ~ Risk, data = allSites$Return, FUN = mean)
ggplot(EFall)+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EFret, aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)")
EFall <- allSites$Frontier
EFall <- aggregate(Mean ~ Seed + RA, data = EFall, FUN = mean)
maxW <- aggregate(Mean ~ Seed, data = EFall, FUN = max)
EFall <- EFall[EFall$Seed %in% maxW$Seed[maxW$Mean > 0.05],]
for(R in unique(EFall$RA)){###scale each out of 1
EFall$Mean[EFall$RA == R] <- EFall$Mean[EFall$RA == R]/sum(EFall$Mean[EFall$RA == R])
}
EFret <- aggregate(MeanRet ~ Risk, data = allSites$Return, FUN = mean)
ggplot(EFall)+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EFret, aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)")
SeedList <- unique(SuitTable$Seed)
SiteList <- as.character(SSPredAll$SiteNo[SSPredAll$BGC == "SBSmc2"])
outRaw <- data.frame(Seed = SeedList, Number = 0)
SiteList <- as.character(SSPredAll$SiteNo[SSPredAll$BGC == "SBSmc2"])
outRaw <- data.frame(Seed = SeedList, Number = 0)
###foreach site
allSites <- foreach(SNum = SiteList[1:6], .combine = combineList,.packages = c("scales", "foreach","reshape2","dplyr","magrittr","PortfolioAnalytics")) %do% {
EF.out.all <- data.frame(Seed = "SBSmc2", RA = 2)
EF.ret.all <- data.frame(RA = 2)
SSPred <- SSPredAll[SSPredAll$SiteNo == SNum,]
currBGC <- as.character(SSPred$BGC[1])
SSPred <- merge(SSPred,SuitTable, by.x = "BGC.pred", by.y = "Site", all.x = TRUE)
modList <- as.character(unique(SSPred$GCM))
output <- data.frame(Seed = SeedList)
for(mod in modList){
SSPredMod <- SSPred[SSPred$GCM == mod,]
returns <- data.frame(Year = seq(2000,2100,1))
modData <- data.frame(Year = seq(2000,2100,1))
##plot(0,0, type = "n", xlim = c(1,100), ylim = c(0,50), xlab = "Year", ylab = "Volume")###plot
for(seed in SeedList){
SSPredSd <- SSPredMod[SSPredMod$Seed == seed,]
SSPredSd <- SSPredSd[order(SSPredSd$GCM,SSPredSd$FuturePeriod),]
SS.sum <- SSPredSd[,c("FuturePeriod","HTp_pred")]
colnames(SS.sum)[2] <- "Growth"
curr <- data.frame(FuturePeriod = 2000, Growth = SuitTable$HTp_pred[SuitTable$Site == as.character(SSPredMod$BGC[1]) &
SuitTable$Seed == as.character(seed)])
SS.sum <- rbind(curr, SS.sum)
SS.sum$Growth <- (SS.sum$Growth - 0.9)*10
SS.sum <- SS.sum[complete.cases(SS.sum),]
if(any(SS.sum$Growth < 0)){next}
outRaw$Number[outRaw$Seed == seed] <- outRaw$Number[outRaw$Seed == seed] + 1##count number of times BGC is used
cols <- rainbow(50)
annualDat <- data.frame("Year" = seq(2000,2100,1))
portOutput <- data.frame("Seed" = SeedList)###set up plot and output
## s <- approx(SS.sum$FuturePeriod, SS.sum$Growth, n = 101) ##Smooth SI
s <- spline(SS.sum$FuturePeriod, SS.sum$Growth, n = 101)
growthRate <- s[["y"]]
#lines(growthRate)
pDead <- 1 - s[["y"]]
pDead <- rescale(pDead, to = c(0.01,0.1), from = c(0,1))
nTrees <- 100 ##number of tree to start
Returns <- numeric(length = 101)
###Simulate Growth
for (i in 1:101){ ##for each year
height <- sum(growthRate[1:i]) ##total height
Returns[i] <- nTrees*height ##volume
prevTrees <- nTrees
percentDead <- rgamma(1, shape = 1, scale = pDead[i])###what percent of trees will die based on gamma distribution?
numDead <- (percentDead/100)*prevTrees###number of dead trees
nTrees <- prevTrees - numDead ##update number of trees
} ##for each year
returns <- cbind(returns, Returns)
colnames(returns)[length(returns)] <- seed
assets <- vector("numeric", 101)
assets[1] <- Returns[1]
for (z in 1:100){ ##convert from cumulative volume to change by year
assets[z+1] <- Returns[z+1] - Returns[z]
}
#lines(assets)
modData <- cbind(modData, assets)
colnames(modData)[length(modData)] <- seed
}
if(ncol(modData) < 3){next}
returns <- modData
rownames(returns) <- paste(returns$Year,"-01-01", sep = "")
returns <- returns[,-1]
#returns <- returns[1:76,]
returnsTS <- as.xts(returns)
init.portfolio <- portfolio.spec(assets = colnames(returnsTS))
nSpp <- length(colnames(returnsTS))
init.portfolio <- add.constraint(portfolio = init.portfolio, type = "weight_sum", min_sum = 0.9, max_sum = 1.1) ###weights should add to about 1
init.portfolio <- add.constraint(portfolio = init.portfolio, type = "box", min = rep(0, nSpp), max = rep(0.95, nSpp)) ##set min and max weight for each species
for(q in seq(from = 2, to = 50, by = 2)){
qu <- add.objective(portfolio=init.portfolio, type="return", name="mean")
qu <- add.objective(portfolio=qu, type="risk", name="var", risk_aversion = q)
minSD.opt <- optimize.portfolio(R = returnsTS, portfolio = qu, optimize_method = "ROI", trace = TRUE)
if(q == 2){
EF.out <-  as.data.frame(minSD.opt[["weights"]])
EF.out$Seed <- rownames(EF.out)
EF.out$RA <- q
EF.ret <- as.data.frame(minSD.opt[["objective_measures"]][["mean"]])
EF.ret$RA <- q
}else{
temp <- as.data.frame(minSD.opt[["weights"]])
temp$Seed <- rownames(temp)
temp$RA <- q
EF.out <- rbind(EF.out, temp)
temp <- as.data.frame(minSD.opt[["objective_measures"]][["mean"]])
temp$RA <- q
EF.ret <- rbind(EF.ret, temp)
}
}
EF.out.all <- merge(EF.out.all, EF.out, by = c("Seed","RA"), all = TRUE)
EF.ret.all <- merge(EF.ret.all, EF.ret, by = "RA", all = TRUE)
}
##if(length(unique(EF.out.all$Seed)) > 2){
EF.out.all$NumNA <- apply(is.na(EF.out.all), 1, FUN = sum)##number of models where it didn't show up
EF.out.all <- EF.out.all[EF.out.all$NumNA < 8,] ##remove seed stock showing up in < 50% of models
EF.out.all[is.na(EF.out.all)] <- 0
EF.out.all$Mean <- apply(EF.out.all[,-c(1,2,length(EF.out.all))],1,mean) ### mean of weights
for(R in EF.out.all$RA){###scale each out of 1
EF.out.all$Mean[EF.out.all$RA == R] <- EF.out.all$Mean[EF.out.all$RA == R]/sum(EF.out.all$Mean[EF.out.all$RA == R])
}
EF.ret.all$Mean <- apply(EF.ret.all[,-1],1,mean, na.rm = TRUE) ###mean of returns
EF.ret.all$Mean <- EF.ret.all$Mean/max(EF.ret.all$Mean) ##scale return out of 1
EF.ret.all <- EF.ret.all[,c(1,length(EF.ret.all))]
colnames(EF.ret.all) <- c("Risk","MeanRet")
EF.sum <- EF.out.all[,c("Seed","RA","Mean")]
print(ggplot(EF.sum)+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EF.ret.all, aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)"))
if(nrow(EF.sum) > 0){
EF.sum$Site <- SNum
}
EF.ret.all$Site <- SNum
outList <- list(Frontier = EF.sum, Return = EF.ret.all)
outList
##}
}
View(allSites)
View(allSites[["Frontier"]])
set.seed(123321)
coreNum <- as.numeric(detectCores()-2)
coreNo <- makeCluster(coreNum)
registerDoParallel(coreNo, cores = coreNum)
SiteList <- as.character(SSPredAll$SiteNo[SSPredAll$BGC == "SBSmc2"])
outRaw <- data.frame(Seed = SeedList, Number = 0)
###foreach site
allSites <- foreach(SNum = SiteList[1:50], .combine = combineList,.packages = c("scales", "foreach","reshape2","dplyr","magrittr","PortfolioAnalytics")) %dopar% {
EF.out.all <- data.frame(Seed = "SBSmc2", RA = 2)
EF.ret.all <- data.frame(RA = 2)
SSPred <- SSPredAll[SSPredAll$SiteNo == SNum,]
currBGC <- as.character(SSPred$BGC[1])
SSPred <- merge(SSPred,SuitTable, by.x = "BGC.pred", by.y = "Site", all.x = TRUE)
modList <- as.character(unique(SSPred$GCM))
output <- data.frame(Seed = SeedList)
for(mod in modList){
SSPredMod <- SSPred[SSPred$GCM == mod,]
returns <- data.frame(Year = seq(2000,2100,1))
modData <- data.frame(Year = seq(2000,2100,1))
##plot(0,0, type = "n", xlim = c(1,100), ylim = c(0,50), xlab = "Year", ylab = "Volume")###plot
for(seed in SeedList){
SSPredSd <- SSPredMod[SSPredMod$Seed == seed,]
SSPredSd <- SSPredSd[order(SSPredSd$GCM,SSPredSd$FuturePeriod),]
SS.sum <- SSPredSd[,c("FuturePeriod","HTp_pred")]
colnames(SS.sum)[2] <- "Growth"
curr <- data.frame(FuturePeriod = 2000, Growth = SuitTable$HTp_pred[SuitTable$Site == as.character(SSPredMod$BGC[1]) &
SuitTable$Seed == as.character(seed)])
SS.sum <- rbind(curr, SS.sum)
SS.sum$Growth <- (SS.sum$Growth - 0.9)*10
SS.sum <- SS.sum[complete.cases(SS.sum),]
if(any(SS.sum$Growth < 0)){next}
outRaw$Number[outRaw$Seed == seed] <- outRaw$Number[outRaw$Seed == seed] + 1##count number of times BGC is used
cols <- rainbow(50)
annualDat <- data.frame("Year" = seq(2000,2100,1))
portOutput <- data.frame("Seed" = SeedList)###set up plot and output
## s <- approx(SS.sum$FuturePeriod, SS.sum$Growth, n = 101) ##Smooth SI
s <- spline(SS.sum$FuturePeriod, SS.sum$Growth, n = 101)
growthRate <- s[["y"]]
#lines(growthRate)
pDead <- 1 - s[["y"]]
pDead <- rescale(pDead, to = c(0.01,0.1), from = c(0,1))
nTrees <- 100 ##number of tree to start
Returns <- numeric(length = 101)
###Simulate Growth
for (i in 1:101){ ##for each year
height <- sum(growthRate[1:i]) ##total height
Returns[i] <- nTrees*height ##volume
prevTrees <- nTrees
percentDead <- rgamma(1, shape = 1, scale = pDead[i])###what percent of trees will die based on gamma distribution?
numDead <- (percentDead/100)*prevTrees###number of dead trees
nTrees <- prevTrees - numDead ##update number of trees
} ##for each year
returns <- cbind(returns, Returns)
colnames(returns)[length(returns)] <- seed
assets <- vector("numeric", 101)
assets[1] <- Returns[1]
for (z in 1:100){ ##convert from cumulative volume to change by year
assets[z+1] <- Returns[z+1] - Returns[z]
}
#lines(assets)
modData <- cbind(modData, assets)
colnames(modData)[length(modData)] <- seed
}
if(ncol(modData) < 3){next}
returns <- modData
rownames(returns) <- paste(returns$Year,"-01-01", sep = "")
returns <- returns[,-1]
#returns <- returns[1:76,]
returnsTS <- as.xts(returns)
init.portfolio <- portfolio.spec(assets = colnames(returnsTS))
nSpp <- length(colnames(returnsTS))
init.portfolio <- add.constraint(portfolio = init.portfolio, type = "weight_sum", min_sum = 0.9, max_sum = 1.1) ###weights should add to about 1
init.portfolio <- add.constraint(portfolio = init.portfolio, type = "box", min = rep(0, nSpp), max = rep(0.95, nSpp)) ##set min and max weight for each species
for(q in seq(from = 2, to = 50, by = 2)){
qu <- add.objective(portfolio=init.portfolio, type="return", name="mean")
qu <- add.objective(portfolio=qu, type="risk", name="var", risk_aversion = q)
minSD.opt <- optimize.portfolio(R = returnsTS, portfolio = qu, optimize_method = "ROI", trace = TRUE)
if(q == 2){
EF.out <-  as.data.frame(minSD.opt[["weights"]])
EF.out$Seed <- rownames(EF.out)
EF.out$RA <- q
EF.ret <- as.data.frame(minSD.opt[["objective_measures"]][["mean"]])
EF.ret$RA <- q
}else{
temp <- as.data.frame(minSD.opt[["weights"]])
temp$Seed <- rownames(temp)
temp$RA <- q
EF.out <- rbind(EF.out, temp)
temp <- as.data.frame(minSD.opt[["objective_measures"]][["mean"]])
temp$RA <- q
EF.ret <- rbind(EF.ret, temp)
}
}
EF.out.all <- merge(EF.out.all, EF.out, by = c("Seed","RA"), all = TRUE)
EF.ret.all <- merge(EF.ret.all, EF.ret, by = "RA", all = TRUE)
}
##if(length(unique(EF.out.all$Seed)) > 2){
EF.out.all$NumNA <- apply(is.na(EF.out.all), 1, FUN = sum)##number of models where it didn't show up
EF.out.all <- EF.out.all[EF.out.all$NumNA < 8,] ##remove seed stock showing up in < 50% of models
EF.out.all[is.na(EF.out.all)] <- 0
EF.out.all$Mean <- apply(EF.out.all[,-c(1,2,length(EF.out.all))],1,mean) ### mean of weights
for(R in EF.out.all$RA){###scale each out of 1
EF.out.all$Mean[EF.out.all$RA == R] <- EF.out.all$Mean[EF.out.all$RA == R]/sum(EF.out.all$Mean[EF.out.all$RA == R])
}
EF.ret.all$Mean <- apply(EF.ret.all[,-1],1,mean, na.rm = TRUE) ###mean of returns
EF.ret.all$Mean <- EF.ret.all$Mean/max(EF.ret.all$Mean) ##scale return out of 1
EF.ret.all <- EF.ret.all[,c(1,length(EF.ret.all))]
colnames(EF.ret.all) <- c("Risk","MeanRet")
EF.sum <- EF.out.all[,c("Seed","RA","Mean")]
# print(ggplot(EF.sum)+
#         geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
#         geom_line(data = EF.ret.all, aes(x = Risk, y = MeanRet), size = 2)+
#         scale_fill_discrete()+
#         labs(x = "Risk (0 = High Risk, 50 = Low Risk)"))
if(nrow(EF.sum) > 0){
EF.sum$Site <- SNum
}
EF.ret.all$Site <- SNum
outList <- list(Frontier = EF.sum, Return = EF.ret.all)
outList
##}
}
7/30
View(allSites)
library(gridExtra)
EFall <- allSites$Frontier
EFret <- allSites$Return
sites <- sample(unique(EFall$Site),6,replace = FALSE)
for(site in sites){
assign(paste(site,"Plot"),
ggplot(EFall[EFall$Site == site,])+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EFret[EFret$Site == site,], aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)"))+
title(site)
}
EFall <- allSites$Frontier
EFret <- allSites$Return
sites <- sample(unique(EFall$Site),6,replace = FALSE)
for(site in sites){
assign(paste(site,"Plot"),
print(ggplot(EFall[EFall$Site == site,])+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EFret[EFret$Site == site,], aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)"))+
title(site))
}
EFall <- allSites$Frontier
EFret <- allSites$Return
sites <- sample(unique(EFall$Site),6,replace = FALSE)
for(site in sites){
assign(paste(site,"Plot"),
ggplot(EFall[EFall$Site == site,])+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EFret[EFret$Site == site,], aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)"))
}
EFall <- allSites$Frontier
EFret <- allSites$Return
sites <- sample(unique(EFall$Site),6,replace = FALSE)
for(site in sites){
print(ggplot(EFall[EFall$Site == site,])+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EFret[EFret$Site == site,], aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)"))
}
##grid.arrange(`145 Plot`,`149 Plot`,)
EFall <- allSites$Frontier
EFret <- allSites$Return
sites <- sample(unique(EFall$Site),6,replace = FALSE)
for(site in sites){
print(ggplot(EFall[EFall$Site == site,])+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EFret[EFret$Site == site,], aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)"))
}
##grid.arrange(`145 Plot`,`149 Plot`,)
EFall <- allSites$Frontier
EFret <- allSites$Return
sites <- sample(unique(EFall$Site),6,replace = FALSE)
p <- list()
for(i in 1:6){
p[[i]] <- ggplot(EFall[EFall$Site == sites[i],])+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EFret[EFret$Site == sites[i],], aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)")
}
do.call(grid.arrange,p)
EFall <- allSites$Frontier
EFall <- aggregate(Mean ~ Seed + RA, data = EFall, FUN = mean)
maxW <- aggregate(Mean ~ Seed, data = EFall, FUN = max)
EFall <- EFall[EFall$Seed %in% maxW$Seed[maxW$Mean > 0.05],]
for(R in unique(EFall$RA)){###scale each out of 1
EFall$Mean[EFall$RA == R] <- EFall$Mean[EFall$RA == R]/sum(EFall$Mean[EFall$RA == R])
}
EFret <- aggregate(MeanRet ~ Risk, data = allSites$Return, FUN = mean)
ggplot(EFall)+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EFret, aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)")
EFall <- allSites$Frontier
EFall <- aggregate(Mean ~ Seed + RA, data = EFall, FUN = mean)
maxW <- aggregate(Mean ~ Seed, data = EFall, FUN = max)
EFall <- EFall[EFall$Seed %in% maxW$Seed[maxW$Mean > 0.1],]
for(R in unique(EFall$RA)){###scale each out of 1
EFall$Mean[EFall$RA == R] <- EFall$Mean[EFall$RA == R]/sum(EFall$Mean[EFall$RA == R])
}
EFret <- aggregate(MeanRet ~ Risk, data = allSites$Return, FUN = mean)
ggplot(EFall)+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EFret, aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)")
EFall <- allSites$Frontier
EFall <- aggregate(Mean ~ Seed + RA, data = EFall, FUN = mean)
maxW <- aggregate(Mean ~ Seed, data = EFall, FUN = max)
EFall <- EFall[EFall$Seed %in% maxW$Seed[maxW$Mean > 0.15],]
for(R in unique(EFall$RA)){###scale each out of 1
EFall$Mean[EFall$RA == R] <- EFall$Mean[EFall$RA == R]/sum(EFall$Mean[EFall$RA == R])
}
EFret <- aggregate(MeanRet ~ Risk, data = allSites$Return, FUN = mean)
ggplot(EFall)+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EFret, aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)")
EFall <- allSites$Frontier
EFall <- aggregate(Mean ~ Seed + RA, data = EFall, FUN = mean)
maxW <- aggregate(Mean ~ Seed, data = EFall, FUN = max)
EFall <- EFall[EFall$Seed %in% maxW$Seed[maxW$Mean > 0.15],]
for(R in unique(EFall$RA)){###scale each out of 1
EFall$Mean[EFall$RA == R] <- EFall$Mean[EFall$RA == R]/sum(EFall$Mean[EFall$RA == R])
}
EFret <- aggregate(MeanRet ~ Risk, data = allSites$Return, FUN = mean)
ggplot(EFall)+
geom_bar(aes(x = RA, y = Mean, fill = Seed), stat = "identity")+
geom_line(data = EFret, aes(x = Risk, y = MeanRet), size = 2)+
scale_fill_discrete()+
labs(x = "Risk (0 = High Risk, 50 = Low Risk)")
rmarkdown::render("PortExamples.Rmd")
getwd()
?allSites
?save
save(allSites, file = "BulkelyCBSTExample.RData")
devtools::install_github("tinytex")
devtools::install_github("tinytex")
rmarkdown::render(input = "PortExample.Rmd",
output_format = "pdf_document",
output_file = "Test.pdf")
install.packages("tinytex")
install.packages("tinytex")
library(tinytex)
tinytex::install_tinytex()
